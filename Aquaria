#!/usr/bin/perl
# Aquarium Power Manager
# Configuration files are in /etc/Aquaria/schedule
#
# Copyright 2007, Jason S. McMullan <jason.mcmullan@gmail.com>
#
# GPL v2.0
#

$POWER_SWITCH="192.168.0.100";
$DOTDIR="/etc/Aquaria";

$SCHEDULE=$DOTDIR."/schedule";
$ENV{"PATH"} .= ":/opt/Aquaria/bin";

my %Switch;
my %Device;
# Device is a 'class', which points to a hash of 'name', which points to an array of:
#    { 'sensor' => { Temp | Time }, 'state' => ( ON | OFF ),
#      .. sensor specific details
#    )

sub power_set {
	my ($class, $name, $state, $override) = @_;

	my $sw = $Switch{$class}->{$name};

	if (!defined $state) {
		undef $sw->{'override'};
		return;
	}

	if (!defined $override && $sw->{'override'} > time) {
		return;
	}

	if (defined $override) {
		$sw->{'override'} = time + $override;
	} else {
		undef $sw->{'override'};
	}

	if ($state eq $sw->{'state'}) {
		return;
	}

	system("curl --user admin:1234 --silent \"http://$POWER_SWITCH/outlet?".$Switch{$class}->{$name}->{'id'}."=".$state."\" >/dev/null");
	$sw->{'state'} = $state;
}

sub power_get {
	my ($class, $name) = @_;

	return ($Switch{$class}->{$name}->{'state'},
		$Switch{$class}->{$name}->{'override'});
}


sub power_config {
	open(CONF, "curl --user admin:1234 --silent http://$POWER_SWITCH/admin.cgi |") or die "Can't open port to read config!";

	my $id=1;
	my $label;
	while (<CONF>) {
		if ($_ =~ /^\<td\>(.*)\<\/td\>/) {
			$label = $1;
			my ($class,$name) = split(/:/, $label, 2);

			$Switch{$class}->{$name} = { 'id'=>$id };
			$id++;
		}
	}
	close(CONF);
}

sub schedule_config {
	open(SCHED, "< $SCHEDULE") or die "Can't read schedule!";

	my $label;
	while (<SCHED>) {
		chomp;
		$_ =~ s/#.*$//;		# Remove comments

		if ($_ =~ /^Device\s+([^\s]+)\s*$/) {
			$label = $1;
			next;
		}

		if ($_ =~ /\s*(On|Off)\s+Always\s*$/) {
			my $state = $1;
			$state =~ tr/[a-z]/[A-Z]/;

			my ($class,$name) = split(/:/, $label, 2);

			push @{$Device{$class}->{$name}},
				{ 'sensor'=>'Always',
					'state' => $state,
				};
			next;
		}


		if ($_ =~ /^\s*(On|Off)\s+Time\s+([0-9]+):([0-9]+)\s+for\s+([0-9]+):([0-9]+)\s*$/) {
			my $time_start = $2 * 60 + $3;
			my $time_len   = $4 * 60 + $5;
			my $state = $1;
			$state =~ tr/[a-z]/[A-Z]/;

			my ($class,$name) = split(/:/, $label, 2);

			if ( ! defined $Switch{$class}->{$name}->{'id'}) {
				printf STDERR "Device $label is not defined by the switch!";
				exit 1;
			}

			push @{$Device{$class}->{$name}},
				{ 'sensor'=>'Time',
					'state' => $state,
					'start' => $time_start,
					'length' => $time_len,
				};
			next;
		}
		if ($_ =~ /^\s+(On|Off)\s+Temp\s+([<>=!]+)([0-9.]+)([FC])\s*$/) {
			my $state = $1;
			my $condition = $2;
			my $temp = $3;
			my $scale = $4;
			$state =~ tr/[a-z]/[A-Z]/;

			# Convert to degress C
			if ($scale eq 'F') {
				$scale = 'C';
				$temp = (($temp-32) * 5.0/9.0);
			}

			my ($class,$name) = split(/:/, $label, 2);

			if ( ! defined $Switch{$class}->{$name}->{'id'}) {
				printf STDERR "Device $label is not defined by the switch!";
				exit 1;
			}

			push @{$Device{$class}->{$name}},
				{ 'sensor'=> 'Temp',
					'state' => $state,
					'temp' => $temp,
					'condition' => $condition,
				};
			next;
		}

		if ($_ !~ /^\s*$/) {
			printf STDERR "Unrecognized line in schedule:\n$_\n";
			exit 1;
		}
	}

	close(SCHED);
}

sub sensor_time {
	my ($value, $cond, $state) = @_;

	if (($value > $cond->{'start'}) &&
	    ($value < ($cond->{'start'} + $cond->{'length'}))) {
		return $cond->{'state'};
	}

	$value += 24 * 60;

	if (($value > $cond->{'start'}) &&
	    ($value < ($cond->{'start'} + $cond->{'length'}))) {
		return $cond->{'state'};
	}

	return $state;
}

sub sensor_temp {
	my ($value, $cond, $state) = @_;

	my $temp = $cond->{'temp'};

	my $doit = eval "$value $cond->{'condition'} $temp";

	if ($doit) {
		return $cond->{'state'};
	}

	return $state;
}

sub device_check {
	my $t;
	my $event;
	my $time;
	my $temp;

	my $NOW_Hour=`date +%H` + 0;
	my $NOW_Min=`date +%M` + 0;
	my $time = $NOW_Hour * 60 + $NOW_Min;

	my $temp=`gotemp -C` + 0;

	foreach $class (keys %Device) {
		my $name;
		foreach $name (keys %{$Device{$class}}) {
			my $state = 'OFF';
			foreach $cond (@{$Device{$class}->{$name}}) {
				if ($cond->{'sensor'} eq 'Always') {
					$state = $cond->{'state'};
				}
				if ($cond->{'sensor'} eq 'Temp') {
					$state = &sensor_temp($temp, $cond, $state);
				}
				if ($cond->{'sensor'} eq 'Time') {
					$state = &sensor_time($time, $cond, $state);
				}
			}
			&power_set($class, $name,  $state);
		}
	}
}

my $colon = 0;

sub timestamp {
	my $date=`date +"   %m%d%H%M"`;

	chomp $date;
	&ip_usbph("digit \"$date\"");
	if ($colon) {
		&ip_usbph("symbol colon on");
	} else {
		&ip_usbph("symbol colon off");
	}
	$colon ^= 1;
}

sub show_menu {
	my ($class, $name) = @_;

	my $title;
	my $state;

	if ($class eq '') {
		&ip_usbph("symbol man off");
		&ip_usbph("symbol up off");
		&ip_usbph("symbol down off");
		&ip_usbph("top \"TEMP\"");
		&ip_usbph("symbol decimal on");
		my $temp=`gotemp -F`;
		chomp $temp;
		$temp = sprintf("%4d", $temp * 10);
		&ip_usbph("bot \"$temp\"");
		return;
	}

	&ip_usbph("symbol decimal off");
	if ($name eq '') {
		$title = $class;
		$title =~ tr/a-z/A-Z/;
		$title = sprintf("%-5.5s ->", $title);
		&ip_usbph("symbol man off");
		&ip_usbph("symbol up off");
		&ip_usbph("symbol down off");
		&ip_usbph("top \"$title\"");
		&ip_usbph("bot \"\"");
		return;
	}

	# We have class and name
	$title = $name;
	$title =~ tr/a-z/A-Z/;
	$title = sprintf("*%7.7s", $title);
	my $override;
	($state, $override) = &power_get($class, $name);
	if ($state eq 'ON') {
		&ip_usbph("symbol up on");
		&ip_usbph("symbol down off");
	} else {
		&ip_usbph("symbol up off");
		&ip_usbph("symbol down on");
	}

	&ip_usbph("top \"$title\"");
	if (defined $override) {
		$override = sprintf("%4d", $override - time);
		&ip_usbph("bot \"$override\"");
		&ip_usbph("symbol man on");
	} else {
		&ip_usbph("bot \"\"");
		&ip_usbph("symbol man off");
	}
}

sub handle_key {
	my ($class, $name, $key) = @_;

	my @classes = sort keys %Switch;

	if ($class eq '') {
		($class) = @classes;
		return ($class, $name);
	} elsif ($name eq '') {
		if ($key eq 'VOL-' or $key eq '4') {
			$class = '';
		} elsif ($key eq 'VOL+' or $key eq '6') {
			($name) = sort keys %{$Switch{$class}};
		} elsif ($key eq 'DOWN' or $key eq '8') {
			my $i;
			for ($i = 0; $i < @classes; $i++) {
				if ($classes[$i] eq $class) {
					$i = ($i + 1) % @classes;
					$class = $classes[$i];
					last;
				}
			}
		} elsif ($key eq 'UP' or $key eq '2') {
			my $i;
			for ($i = 0; $i < @classes; $i++) {
				if ($classes[$i] eq $class) {
					$i = ($i + $#classes) % @classes;
					$class = $classes[$i];
					last;
				}
			}
		}
		return ($class, $name);
	}

	my @names = sort keys %{$Switch{$class}};

	if ($key eq 'VOL-' or $key eq '4') {
		$name = '';
	} elsif ($key eq 'DOWN' or $key eq '8') {
		my $i;
		for ($i = 0; $i < @names; $i++) {
			if ($names[$i] eq $name) {
				$i = ($i + 1) % @names;
				$name = $names[$i];
				last;
			}
		}
	} elsif ($key eq 'UP' or $key eq '2') {
		my $i;
		for ($i = 0; $i < @names; $i++) {
			if ($names[$i] eq $name) {
				$i = ($i + $#names) % @names;
				$name = $names[$i];
				last;
			}
		}
	} elsif ($key eq 'YES') {
		&power_set($class, $name, "ON", 15*60);
	} elsif ($key eq 'NO') {
		&power_set($class, $name, "OFF", 15*60);
	} elsif ($key eq 'C') {
		&power_set($class, $name);
	}

	return ($class, $name);
}

sub ip_usbph_init {
	return;

	system("rm -f /tmp/ip-usbph.get");
	system("mkfifo /tmp/ip-usbph.get");

	open(IP_USBPH_CMD,"| ip-usbph pipe >/tmp/ip-usbph.get") or die "ip-usbph: $!";
	open(IP_USBPH_GET,"< /tmp/ip-usbph.get");
	my $fd = select IP_USBPH_CMD;
	$|=1;
	select $fd;
}

sub ip_usbph_reinit {
	return;

	print STDERR "Re-initiallizing...\n";
	close(IP_USBPH_CMD);
	close(IP_USBPH_GET);
	sleep(1);
	&ip_usbph_init;
}

sub ip_usbph {
	return;

	my ($cmd) = @_;
	print IP_USBPH_CMD $cmd."\n" or &ip_usbph_reinit;
}

sub ip_usbph_get {
	sleep 15;
	return;

	my ($cmd) = @_;
	&ip_usbph($cmd);
	$get = <IP_USBPH_KEY>;
	if ($!) { &ip_usbph_reinit };
	chomp $get;
	return $get;
}

sub main {
	&ip_usbph_init;
	&ip_usbph("clear");
	&ip_usbph("symbol m_and_d on");

	my $idle;
	my $class = '';
	my $name = '';

	# Generate the power port ID configuration
	&power_config;

	# Read the schedule
	&schedule_config;

	my $NOW_Hour;
	my $NOW_Min;
	my $NOW;

	while (1) {
		&timestamp();
		$key=&ip_usbph_get("key 1000");
		chomp $key;
		if ( $key eq '') {
			$idle++;
			if ($idle == 10) {
				#$class = '';
				#$name  = '';
				$idle = 0;
			}
		} else {
			&ip_usbph("backlight");
			($class, $name) = &handle_key($class, $name, $key);
		}

		&show_menu($class, $name);
		&device_check();
	}
}

&main;
1;
