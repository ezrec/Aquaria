#!/usr/bin/perl
# Aquarium Power Manager
# Configuration files are in /etc/Aquaria/schedule
#
# Copyright 2007, Jason S. McMullan <jason.mcmullan@gmail.com>
#
# GPL v2.0
#

$DOTDIR="/etc/Aquaria";
$SCHEDULE=$DOTDIR."/schedule";
$ENV{"PATH"} .= ":/opt/Aquaria/bin";

my %Switch;
my %Schedule;
my %Threshold;

sub power_set {
	my ($class, $name, $state, $override) = @_;

	my $sw = $Switch{$class}->{$name};

	if (!defined $state) {
		undef $sw->{'override'};
		return;
	}

	if (!defined $override && $sw->{'override'} > time) {
		return;
	}

	if (defined $override) {
		$sw->{'override'} = time + $override;
	} else {
		undef $sw->{'override'};
	}

	if ($state eq $sw->{'state'}) {
		return;
	}

	system("curl --user admin:1234 --silent \"http://192.168.0.100/outlet?".$Switch{$class}->{$name}->{'id'}."=".$state."\" >/dev/null");
	$sw->{'state'} = $state;
}

sub power_get {
	my ($class, $name) = @_;

	return ($Switch{$class}->{$name}->{'state'},
		$Switch{$class}->{$name}->{'override'});
}


sub power_config {
	open(CONF, "curl --user admin:1234 --silent http://192.168.0.100/admin.cgi |") or die "Can't open port to read config!";

	my $id=1;
	my $label;
	while (<CONF>) {
		if ($_ =~ /^\<td\>(.*)\<\/td\>/) {
			$label = $1;
			my ($class,$name) = split(/:/, $label, 2);

			$Switch{$class}->{$name} = { 'id'=>$id };
			$id++;
		}
		if ($_ =~ /^<b><font color=[a-z]*>([A-Z]*)<\/font>/) {
			my ($class,$name) = split(/:/, $label, 2);

			$Switch{$class}->{$name}->{'state'} = $1;
		}
	}
	close(CONF);

	open(SCHED, "< $SCHEDULE") or die "Can't read schedule!";

	while (<SCHED>) {
		if ($_ =~ /^Time\s+([0-9][0-9]):([0-9][0-9])\s+(On|Off)\s+([^\s]*)\s*$/) {
			my $time = $1 * 60 + $2;
			my $state = $3;
			$state =~ tr/[a-z]/[A-Z]/;
			my $label = $4;

			my ($class,$name) = split(/:/, $label, 2);

			if ( ! defined $Switch{$class}->{$name}->{'id'}) {
				printf STDERR "Label $label is not defined by the switch!";
				exit 1;
			}

			push @{$Schedule{$time}},
				{ 'class'=>$class, 'name'=>$name, 'state'=>$state};
		}
		if ($_ =~ /^Temp\s+([<>=!]+)([0-9.]+)([FC])\s+(On|Off)\s+([^\s]*)\s*$/) {
			my $condition = $1;
			my $temp = $2;
			my $scale = $3;
			my $state = $4;
			$state =~ tr/[a-z]/[A-Z]/;
			my $label = $5;

			# Convert to degress C
			if ($scale eq 'F') {
				$scale = 'C';
				$temp = (($temp-32) * 5.0/9.0);
			}

			my ($class,$name) = split(/:/, $label, 2);

			if ( ! defined $Switch{$class}->{$name}->{'id'}) {
				printf STDERR "Label $label is not defined by the switch!";
				exit 1;
			}

			push @{$Threshold{$class}->{$name}}, {'temp'=>$temp, 'condition' => $condition, 'state' => $state };
		}
	}

	close(SCHED);
}

sub schedule_check {
	my ($end)=@_;

	my $t;
	my $event;
	my %switch;

	for ($t = 0; $t <= $end; $t++) {
		next if (! defined $Schedule{$t} );
		foreach $event (@{$Schedule{$t}}) {
			$switch{$event->{'class'}}->{$event->{'name'}}->{'state'}=$event->{'state'};
		}
	}

	foreach $class (keys %switch) {
		my $name;
		foreach $name (keys %{$switch{$class}}) {
			my $sw = $switch{$class}->{$name};
			&power_set($class, $name,  $sw->{'state'});
		}
	}
}

sub temp_check {
	my $class;

	`gotemp -C`;
	my $curr_temp=`gotemp -C`;

	foreach $class (keys %Threshold) {
		my $name;
		foreach $name (keys %{$Threshold{$class}}) {
			foreach $thresh (@{$Threshold{$class}->{$name}}) {
				my $cond = $thresh->{'condition'};
				my $temp = $thresh->{'temp'};

				my $doit = eval "$curr_temp $cond $temp";

				if ($doit) {
					&power_set($class, $name, $thresh->{'state'});
				}
			}
		}
	}
}

my $colon = 0;

sub timestamp {
	my $date=`date +"   %m%d%H%M"`;

	chomp $date;
	&ip_usbph("digit \"$date\"");
	if ($colon) {
		&ip_usbph("symbol colon on");
	} else {
		&ip_usbph("symbol colon off");
	}
	$colon ^= 1;
}

sub show_menu {
	my ($class, $name) = @_;

	my $title;
	my $state;

	if ($class eq '') {
		&ip_usbph("symbol man off");
		&ip_usbph("symbol up off");
		&ip_usbph("symbol down off");
		&ip_usbph("top \"TEMP\"");
		&ip_usbph("symbol decimal on");
		my $temp=`gotemp -F`;
		chomp $temp;
		$temp = sprintf("%4d", $temp * 10);
		&ip_usbph("bot \"$temp\"");
		return;
	}

	&ip_usbph("symbol decimal off");
	if ($name eq '') {
		$title = $class;
		$title =~ tr/a-z/A-Z/;
		$title = sprintf("%-5.5s ->", $title);
		&ip_usbph("symbol man off");
		&ip_usbph("symbol up off");
		&ip_usbph("symbol down off");
		&ip_usbph("top \"$title\"");
		&ip_usbph("bot \"\"");
		return;
	}

	# We have class and name
	$title = $name;
	$title =~ tr/a-z/A-Z/;
	$title = sprintf("*%7.7s", $title);
	my $override;
	($state, $override) = &power_get($class, $name);
	if ($state eq 'ON') {
		&ip_usbph("symbol up on");
		&ip_usbph("symbol down off");
	} else {
		&ip_usbph("symbol up off");
		&ip_usbph("symbol down on");
	}

	&ip_usbph("top \"$title\"");
	if (defined $override) {
		$override = sprintf("%4d", $override - time);
		&ip_usbph("bot \"$override\"");
		&ip_usbph("symbol man on");
	} else {
		&ip_usbph("bot \"\"");
		&ip_usbph("symbol man off");
	}
}

sub handle_key {
	my ($class, $name, $key) = @_;

	my @classes = sort keys %Switch;

	if ($class eq '') {
		($class) = @classes;
		return ($class, $name);
	} elsif ($name eq '') {
		if ($key eq 'VOL-') {
			$class = '';
		} elsif ($key eq 'VOL+') {
			($name) = sort keys %{$Switch{$class}};
		} elsif ($key eq 'DOWN') {
			my $i;
			for ($i = 0; $i < @classes; $i++) {
				if ($classes[$i] eq $class) {
					$i = ($i + 1) % @classes;
					$class = $classes[$i];
					last;
				}
			}
		} elsif ($key eq 'UP') {
			my $i;
			for ($i = 0; $i < @classes; $i++) {
				if ($classes[$i] eq $class) {
					$i = ($i + $#classes) % @classes;
					$class = $classes[$i];
					last;
				}
			}
		}
		return ($class, $name);
	}

	my @names = sort keys %{$Switch{$class}};

	if ($key eq 'VOL-') {
		$name = '';
	} elsif ($key eq 'DOWN') {
		my $i;
		for ($i = 0; $i < @names; $i++) {
			if ($names[$i] eq $name) {
				$i = ($i + 1) % @names;
				$name = $names[$i];
				last;
			}
		}
	} elsif ($key eq 'UP') {
		my $i;
		for ($i = 0; $i < @names; $i++) {
			if ($names[$i] eq $name) {
				$i = ($i + $#names) % @names;
				$name = $names[$i];
				last;
			}
		}
	} elsif ($key eq 'YES') {
		&power_set($class, $name, "ON", 15*60);
	} elsif ($key eq 'NO') {
		&power_set($class, $name, "OFF", 15*60);
	} elsif ($key eq 'C') {
		&power_set($class, $name);
	}

	return ($class, $name);
}

sub ip_usbph_init {
	`mkfifo /tmp/ip-usbph.get`;

	open(IP_USBPH_CMD, "| ip-usbph pipe >/tmp/ip-usbph.get") or die "ip-usbph: $?";
	open(IP_USBPH_GET, "< /tmp/ip-usbph.get") or die "/tmp/ip-usbph.get: $?";

	my $fd = select(IP_USBPH_CMD);
	$| = 1;
	select($fd);
}

sub ip_usbph {
	my ($cmd) = @_;
	print IP_USBPH_CMD $cmd."\n";
}

sub ip_usbph_get {
	my ($cmd) = @_;
	&ip_usbph($cmd);
	$get = <IP_USBPH_GET>;
	chomp $get;
	return $get;
}

sub main {
	&ip_usbph_init;
	&ip_usbph("clear");
	&ip_usbph("symbol m_and_d on");

	my $idle;
	my $class = '';
	my $name = '';

	# Generate the power port ID configuration
	&power_config;

	my $NOW_Hour;
	my $NOW_Min;
	my $NOW;

	while (1) {
		&timestamp();
		$key=&ip_usbph_get("key 1000");
		chomp $key;
		if ( $key eq '') {
			$idle++;
			if ($idle == 10) {
				#$class = '';
				#$name  = '';
				$idle = 0;
			}
		} else {
			&ip_usbph("backlight");
			($class, $name) = &handle_key($class, $name, $key);
		}

		&show_menu($class, $name);
		$NOW_Hour=`date +%H` + 0;
		$NOW_Min=`date +%M` + 0;
		$NOW = $NOW_Hour * 60 + $NOW_Min;

		&schedule_check($NOW);
		&temp_check();
	}
}

&main;
1;
